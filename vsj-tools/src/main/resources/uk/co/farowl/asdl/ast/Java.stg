/*
 * Templates for the generation of Java source from the ASDL AST.
 */

// Java type to use in place of ASDL type (single id)
asdlTypeToJava ::= [
    "identifier" : "String",
    "string" : "String",
    "bytes" : "byte[]",
    "object" : "Object",
    "singleton" : "Object",
    default: key
]

// Java type to use in place of ASDL type (optional or sequence)
asdlTypeToJavaObjectType ::= [
    "identifier" : "String",
    "string" : "String",
    "bytes" : "byte[]",
    "int" : "Integer",
    "object" : "Object",
    "singleton" : "Object",
    default: key
]

// Emit an Abstract Syntax Definition source file for the module
main(command, asdlCodeRoot, asdlPackagePath) ::= <<
// Generated by <command.tool> from
// <command.file>
// using template "<command.template>" in group file
// <command.groupfile>
//
<if(asdlPackagePath)>package <asdlPackagePath;separator="."><endif>

/**
 * Outer class scoping the types defined in the ASDL file
 * \<code><command.file>\</code>, module \<code><asdlCodeRoot.name>\</code>.
 */
public abstract class <asdlCodeRoot.name>AST {

    /**
     * All definitions in this module implement this interface to
     * support a generic approach to walking the tree.
     */
    public interface Node {
        /**
         * Allows a \<code>Visitor\</code> to visit this \<code>Node\</code>
         * without knowing its exact type. The \<code>Node\</code> dispatches
         * to the appropriate type-specific method of the visitor.
         */
        default \<T> T accept(Visitor\<T> visitor){
            return null;
        }
        /**
         * Collects all the non-null children (members and attributes)
         * of this \<code>Node\</code> whose type is defined in this module.
         */
        default java.util.Collection\<Node> children() {
            return java.util.Collections.emptyList();
        }
    }

    <asdlCodeRoot.defs: definition(); separator="\n\n">

    public interface Visitor\<T> {
        <asdlCodeRoot.defs: definitionVisit(); separator="\n">
    }
}
>>

definition(def) ::= <<
<if(def.sum)>
<if(def.simple)><simpleSumDef(def)>
<else><sumDef(def)>
<endif>
<else><productDef(def)>
<endif>
>>

// Declaration of Node class when definition is a product.
productDef(prod) ::= <<
public static class <prod.name> implements Node {
    <prod.members: memberDeclaration(); separator="\n">
    <prod.attributes: memberDeclaration(); separator="\n">

    <constructor(prod.name, [prod.members, prod.attributes])>

    <children([prod.members, prod.attributes])>

    public \<T> T accept(Visitor\<T> visitor) {
        return visitor.visit_<prod.name>(this);
    }
}
>>

constructor(name, args) ::=<<
<constructorHead(name, args)> {
    <args: memberInitStmt(); separator="\n">
}
>>

memberInitStmt(m) ::= "this.<m.name> = <m.name>;"

memberDeclaration(field) ::= <%
    <declaredType(field)><" ">
    <field.name>;
%>

// Choose object or collection type according to cardinality
declaredType(field) ::= <%
<if(field.optional)>
    <asdlTypeToJavaObjectType.(field.type.name)>
<elseif(field.sequence)>
    java.util.List\<<asdlTypeToJavaObjectType.(field.type.name)>>
<else>
    <asdlTypeToJava.(field.type.name)>
<endif>
%>

// Emit the implementation of Node::children()
children(members) ::= <<
<if(members)>
public java.util.Collection\<Node> children() {
    java.util.List\<Node> list = new java.util.LinkedList\<>();
    <members: childrenAdd(); separator="\n">
    return list;
}
<endif>
>>

childrenAdd(field) ::= <%
<if(!field.nodeType)>
    // <field.name> has non-Node type <field.type.name>
<elseif(field.optional)>
    if (<field.name>!=null) list.add(<field.name>);
<elseif(field.sequence)>
    list.addAll(<field.name>);
<else>
    list.add(<field.name>);
<endif>
%>

// Declaration of Node class when definition is a simple sum.
simpleSumDef(sum) ::= <%
public enum <sum.name> implements Node {
    <sum.constructors: {c|<c.name>}; separator=", ">
}
%>

// Declaration of Node class when definition is a sum.
sumDef(sum) ::= <<
public static abstract class <sum.name> implements Node {

    <sum.constructors: constructorType(sum); separator="\n\n">

    <sum.attributes: memberDeclaration(); separator="\n">

    <constructor(sum.name, sum.attributes)>
}
>>

// One alternative within a sum type definition
constructorType(con, def) ::= <<
public static class <con.name> extends <def.name> {
    <con.members: memberDeclaration(); separator="\n">
    <constructorHead(con.name, [con.members, def.attributes])>{
        super(<def.attributes: {m|<m.name>}; separator=", ">);
        <con.members: memberInitStmt(); separator="\n">
    }

    <children([con.members, def.attributes])>

    public \<T> T accept(Visitor\<T> visitor) {
        return visitor.visit_<con.name>(this);
    }
}
>>

constructorHead(name, args) ::= <%
    public <name>(
    <args: argDecl(); separator=", ">
    )
%>

// Declaration of a field argument (for constructors)
argDecl(field) ::= "<declaredType(field)> <field.name>"

// Generate visit method(s) for a Definition
definitionVisit(def) ::= <<
<if(def.sum)>
<if(def.simple)><simpleSumDefVisit(def)>
<else><sumDefVisit(def)>
<endif>
<else><productDefVisit(def)>
<endif>
>>

// Declaration of visit method when definition is a product.
productDefVisit(prod) ::= <<
T visit_<prod.name>(<prod.name> _<prod.name>);
>>

// Declaration of visit method when definition is a simple sum.
simpleSumDefVisit(sum) ::= <<
T visit_<sum.name>(<sum.name> _<sum.name>);
>>

// Declaration of visit method when definition is a sum.
sumDefVisit(sum) ::= <<
<sum.constructors: constructorTypeVisit(sum); separator="\n">
>>

// Visit one alternative within a sum type definition
constructorTypeVisit(con, def) ::= <<
T visit_<con.name>(<def.name>.<con.name> _<con.name>);
>>


