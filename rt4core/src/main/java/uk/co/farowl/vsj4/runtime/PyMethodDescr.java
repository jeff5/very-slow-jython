// Copyright (c)2025 Jython Developers.
// Licensed to PSF under a contributor agreement.
package uk.co.farowl.vsj4.runtime;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.invoke.WrongMethodTypeException;
import java.util.List;

import uk.co.farowl.vsj4.runtime.ArgumentError.Mode;
import uk.co.farowl.vsj4.runtime.kernel.Representation;
import uk.co.farowl.vsj4.support.InterpreterError;
import uk.co.farowl.vsj4.support.MethodKind;
import uk.co.farowl.vsj4.support.internal.EmptyException;
import uk.co.farowl.vsj4.support.internal.Util;

/**
 * Descriptor for a method defined in Java, that is to be called from
 * Python. A {@code PyMethodDescr} is a callable object itself, and
 * provides binding behaviour through {@link #__get__(Object, PyType)
 * __get__}, which usually creates a {@link PyJavaFunction}.
 * <p>
 * It suits us to sub-class {@code PyMethodDescr} to express the
 * multiplicity of implementations and to respond to the signature of
 * the method, optimising its data flow to arguments. Instances are
 * therefore obtained by calling
 * {@link PyMethodDescr#fromParser(PyType, ArgParser, List) fromParser}.
 */
// Compare CPython: PyMethodDescrObject in descrobject.h
// and functions method_* in descrobject.c.
public abstract class PyMethodDescr extends MethodDescriptor {

    /** The type object of a {@code method_descriptor}. */
    public static final PyType TYPE = PyType.fromSpec( //
            new TypeSpec("method_descriptor", MethodHandles.lookup())
                    .add(Feature.IMMUTABLE, Feature.METHOD_DESCR)
                    .remove(Feature.BASETYPE));

    /*
     * We depart from CPython in reifying information from the Java
     * declaration and associated annotations, not as a separate
     * PyMethodDef but in the PyMethodDescr itself and in an attached
     * argument parser. In CPython, the same information is present at
     * run-time in the structure of the code itself, generated by
     * Argument Clinic, in the flags of the PyMethodDef, and as text in
     * the signature that begins the documentation string.
     */

    /**
     * An argument parser supplied to this {@code PyMethodDescr} at
     * construction, from Java reflection of the implementation and from
     * annotations on it. Full information on the signature is available
     * from this structure, and it is available to parse the arguments
     * to {@link #__call__(Object[], String[])} for methods with a
     * complex signature. (In sub-classes that represent methods with a
     * simple signature, it is only used to generate error messages once
     * validity checks fail.)
     */
    final ArgParser argParser;

    /**
     * Deduced method signature (useful to have cached when constructing
     * a {@link PyJavaFunction}). Note that this is allowed to differ
     * from {@link MethodSignature#fromParser(ArgParser)
     * MethodSignature.fromParser(argParser)}.
     */
    final MethodSignature signature;

    /**
     * Construct a Python {@code method} descriptor, identifying the
     * implementation by a parser and a method handle.
     *
     * @param objclass the class declaring the method
     * @param argParser describing the signature of the method
     * @param signature to which to coerce the handle
     */
    // Compare CPython PyDescr_NewMethod in descrobject.c
    private PyMethodDescr(PyType objclass, ArgParser argParser,
            MethodSignature signature) {
        super(objclass, argParser.name);
        this.argParser = argParser;
        this.signature = signature;
    }

    @Override
    public PyType getType() { return TYPE; }

    /**
     * Construct a Python {@code method} descriptor from an
     * {@link ArgParser} and {@code MethodHandle}s for the
     * implementation methods. The arguments described by the parser do
     * not include "self".
     * <p>
     * In the most common case, where {@code objclass} has only one
     * accepted implementation, there will be only one handle in the
     * {@code candidates} list. Where {@code objclass} has multiple
     * accepted implementations, {@code candidates} may have one entry
     * for each, although it is possible for a single entry with
     * {@code Object self}.
     *
     * @param objclass owning class
     * @param ap argument parser (provides name etc.)
     * @param candidates method handles for the implementations
     * @return a method descriptor supporting the signature
     */
    // Compare CPython PyDescr_NewMethod in descrobject.c
    static PyMethodDescr fromParser(PyType objclass, ArgParser ap,
            List<MethodHandle> candidates) {
        assert ap.methodKind == MethodKind.INSTANCE;
        try {
            if (objclass.selfClasses().size() == 1
                    && candidates.size() == 1) {
                /*
                 * Wrap the single candidate implementation of this
                 * method for the single accepted implementation of
                 * objclass. This is the most common case.
                 */
                MethodHandle mh = candidates.get(0);
                return Single.fromParser(objclass, ap, mh);
            } else {
                /*
                 * There are multiple accepted implementations of
                 * objclass. The constructors here match them to
                 * candidate implementations of ap. (We also land here
                 * if there is not exactly one candidate, relying on the
                 * search for one to fail and throw InternalError.)
                 */
                return Multiple.fromParser(objclass, ap, candidates);
            }
        } catch (WrongMethodTypeException wmte) {
            throw new InterpreterError(wmte,
                    "Failed to create descriptor for '%s.%s'",
                    objclass.getName(), ap.name);
        }
    }

    /**
     * Call this method descriptor for the given target {@code self},
     * and standard arguments ({@code Object[]} and {@code String[]}).
     * We provide this method because it is common to have the
     * descriptor and target object separate from the arguments to a
     * call, for example in an optimised method application.
     * <p>
     * The implementation will arrange the arguments as expected by the
     * handle, or throw if they are not correct for that. In the general
     * case, a call to {@link #argParser} is involved. We create
     * sub-classes of {@link PyMethodDescr} to represent the finite
     * repertoire of {@code MethodSignature}s, that override this method
     * with simplified logic.
     *
     * @param self target object of the method call
     * @param args arguments of the method call
     * @param names of arguments given by keyword or {@code null}
     * @return result of the method call
     * @throws PyBaseException (TypeError) when the arguments
     *     ({@code args} {@code names}) are not correct for the method
     *     signature
     * @throws ArgumentError as a shorthand for {@link PyBaseException
     *     TypeError}, which the caller must convert with
     *     {@link MethodDescriptor#typeError(ArgumentError, Object[])}
     * @throws Throwable from the implementation of the method
     */
    // Compare CPython method_vectorcall_* in descrobject.c
    abstract Object callMethod(Object self, Object[] args,
            String[] names)
            throws ArgumentError, PyBaseException, Throwable;

    /**
     * Call this method descriptor for the given target {@code self},
     * and arguments ({@code Object[]} given only by position.
     * Otherwise, this is the same as
     * {@link #callMethod(Object, Object[], String[])}.
     *
     * @param self target object of the method call
     * @param args arguments of the method call
     * @return result of the method call
     * @throws PyBaseException (TypeError) when the arguments
     *     ({@code args} are not correct for the method signature
     * @throws ArgumentError as a shorthand for {@link PyBaseException
     *     TypeError}, which the caller must convert with
     *     {@link MethodDescriptor#typeError(ArgumentError, Object[])}
     * @throws Throwable from the implementation of the method
     */
    // Compare CPython method_vectorcall_* in descrobject.c
    abstract Object callMethod(Object self, Object[] args)
            throws ArgumentError, PyBaseException, Throwable;

    /*
     * Having defined callMethod in which the first argument self is
     * given special treatment, we now provide a complete set of
     * implementations of call(...). These supersede the default
     * implementations given in FastCall. In FastCall, each makes an
     * array of its arguments for call(args), and ultimately we reach
     * call(args, null).
     *
     * Here instead we express each in terms of callMethod(self, args),
     * to avoid packing self into an array we then have to split. This
     * only has an effect where a sub-class does not further override
     * the method, to deal efficiently with a particular number of
     * positional arguments.
     */

    @Override
    public Object call(Object[] args, String[] names)
            throws ArgumentError, PyBaseException, Throwable {
        int m = args.length - 1;
        if (m < 0) {
            // Not even one argument
            throw new ArgumentError(Mode.SELF);

        } else {
            // Split the leading element self from rest of args
            Object self = args[0], rest[];
            if (m == 0) {
                rest = Util.EMPTY_ARRAY;
            } else {
                rest = new Object[m];
                System.arraycopy(args, 1, rest, 0, m);
            }

            // Call this as a method bound to self.
            return callMethod(self, rest, names);
        }
    }

    @Override
    public Object call(Object self) throws Throwable {
        return callMethod(self, Util.EMPTY_ARRAY);
    }

    @Override
    public Object call(Object self, Object a1) throws Throwable {
        return callMethod(self, new Object[] {a1});
    }

    @Override
    public Object call(Object self, Object a1, Object a2)
            throws Throwable {
        return callMethod(self, new Object[] {a1, a2});
    }

    @Override
    public Object call(Object self, Object a1, Object a2, Object a3)
            throws Throwable {
        return callMethod(self, new Object[] {a1, a2, a3});
    }

    /**
     * Return the handle contained in this descriptor, applicable to the
     * Java class of a {@code self} argument during a call. The
     * implementation must check the Python type of {@code self} is a
     * subclass of the against the type that defined the descriptor.
     * Where the defining type allows multiple (Java) self-classes, the
     * implementation must find the correct one an array.
     *
     * @param self the {@code self} argument in some call
     * @return corresponding handle (or one that throws
     *     {@link EmptyException})
     * @throws PyBaseException (TypeError) if {@code self} is of
     *     unacceptable type
     * @throws Throwable on other errors while chasing the MRO
     */
    abstract MethodHandle getHandle(Object self)
            throws PyBaseException, Throwable;

    // CPython get-set table (to convert to annotations):
    // private GetSetDef method_getset[] = {
    // {"__doc__", (getter)method_get_doc},
    // {"__qualname__", (getter)descr_get_qualname},
    // {"__text_signature__", (getter)method_get_text_signature},
    // {0}
    // };

    // CPython type object (to convert to special method names):
    // PyType PyMethodDescr_Type = {
    // PyVar_HEAD_INIT(&PyType_Type, 0)
    // "method_descriptor",
    // sizeof(PyMethodDescr),
    // 0,
    // offsetof(PyMethodDescr, vectorcall), /* tp_vectorcall_offset */
    // (reprfunc)method_repr, /* tp_repr */
    // PyVectorcall_Call, /* tp_call */
    // PyObject_GenericGetAttr, /* tp_getattro */
    // Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
    // _Py_TPFLAGS_HAVE_VECTORCALL |
    // Py_TPFLAGS_METHOD_DESCRIPTOR, /* tp_flags */
    // descr_methods, /* tp_methods */
    // descr_members, /* tp_members */
    // method_getset, /* tp_getset */
    // (descrgetfunc)method_get, /* tp_descr_get */
    // };

    // special methods ------------------------------------------------

    // Compare CPython method_repr in descrobject.c
    Object __repr__() { return descrRepr("method"); }

    /**
     * Invoke the Java method this method descriptor points to, using
     * the standard {@code __call__} arguments supplied, default
     * arguments and other information described in the associated
     * {@link #argParser} for the method.
     *
     * @param args all arguments beginning with {@code self}
     * @param names of keyword arguments
     * @return result of calling the method represented
     * @throws PyBaseException (TypeError) if {@code args[0]} is of the
     *     wrong type or the pattern of arguments is unacceptable
     *     (number, keyword use).
     * @throws Throwable from the implementation of the method
     */
    Object __call__(Object[] args, String[] names)
            throws PyBaseException, Throwable {
        try {
            if (names != null && names.length != 0) {
                return call(args, names);
            } else {
                int n = args.length;
                switch (n) {
                    // case 0 (an error) handled by default clause
                    case 1:
                        return call(args[0]);
                    case 2:
                        return call(args[0], args[1]);
                    case 3:
                        return call(args[0], args[1], args[2]);
                    case 4:
                        return call(args[0], args[1], args[2], args[3]);
                    default:
                        return call(args);
                }
            }
        } catch (ArgumentError ae) {
            throw typeError(ae, args, names);
        }
    }

    /*
     * A simplified __call__ used in the narrative. To use, rename this
     * to __call__, rename the real __call__ to something else, and
     * force fromParser() always to select General as the implementation
     * type.
     */
    Object simple__call__(Object[] args, String[] names)
            throws PyBaseException, Throwable {
        int m = args.length - 1, nk = names == null ? 0 : names.length;
        try {
            if (m < nk) {
                // Not even one argument (self) given by position
                throw new ArgumentError(Mode.SELF);

            } else {
                // Call this with self and rest of args separately.
                Object self = args[0];
                MethodHandle mh = getHandle(self);
                // Parse args without the leading element self
                Object[] frame = argParser.parse(args, 1, m, names);
                return mh.invokeExact(self, frame);
            }
        } catch (ArgumentError ae) {
            throw typeError(ae, args, names);
        }
    }

    /**
     * Return the described method, bound to {@code obj} as its
     * {@code self} argument, or if {@code obj==null}, return this
     * descriptor. In the non-{@code null} case, {@code __get__} returns
     * a {@link PyJavaFunction}. Calling the returned object invokes the
     * same Java method as this descriptor, with {@code obj} as first
     * argument, and other arguments to the call appended.
     *
     * @param obj target ({@code self}) of the method, or {@code null}
     * @param type ignored
     * @return method bound to {@code obj} or this descriptor.
     * @throws PyBaseException (TypeError) if {@code obj!=null} is not
     *     compatible
     * @throws Throwable on other errors while chasing the MRO
     */
    @Override
    // Compare CPython method_get in descrobject.c
    public Object __get__(Object obj, PyType type)
            throws PyBaseException, Throwable {
        if (obj == null)
            // Return the descriptor itself.
            return this;
        else {
            // Return a callable binding the method and the target
            check(obj);
            return PyJavaFunction.from(this, obj);
        }
    }

    // exposed methods -----------------------------------------------

    // Compare CPython method_get_doc in descrobject.c
    Object get_doc() {
        return PyType.getDocFromInternalDoc(name, argParser.doc());
    }

    // Compare CPython method_get_text_signature in descrobject.c
    Object get_text_signature() {
        return PyType.getTextSignatureFromInternalDoc(name,
                argParser.doc());
    }

    // plumbing ------------------------------------------------------

    /**
     * Construct an array of method handles, one for each Java class
     * that was named as primary, adopted or accepted in the
     * specification of this type, in that order. These are the Java
     * classes of objects that can legitimately be presented as
     * {@code self}. The handles are taken from a list of candidate
     * method handles, and adapted by {@code sig.prepare()}.
     *
     * @param sig handle type information distilled from parser
     * @param candidates handles on which to base return
     * @return method handles aligned to {@code objclass.clases}
     */
    MethodHandle[] prepareCandidates(MethodSignature sig,
            List<MethodHandle> candidates) {

        List<Class<?>> selfClasses = objclass.selfClasses();
        final int N = selfClasses.size();
        MethodHandle[] methods = new MethodHandle[N];

        /*
         * Fill the method array with matching method handles for the
         * primary, adopted and accepted Java representation classes of
         * this type.
         */
        for (int i = 0; i < N; i++) {

            // Seek most specific match for the i.th self-class
            Class<?> sc = selfClasses.get(i);
            MethodHandle match = null;
            // The candidates are sorted most specific first
            for (MethodHandle mh : candidates) {
                MethodType mt = mh.type();
                if (mt.parameterType(0).isAssignableFrom(sc)) {
                    match = mh;
                    break;
                }
            }

            if (match != null) {
                // Prepare handle to match the invocation type.
                methods[i] = sig.prepare(argParser, match);
            } else {
                // No match means no implementation we can use
                throw new InterpreterError(
                        "'%s.%s' not implemented for %s",
                        objclass.getName(), name, sc);
            }
        }

        return methods;
    }

    /**
     * A {@link PyMethodDescr} for use when the owning Python type has
     * just one accepted implementation.
     */
    static abstract class Single extends PyMethodDescr {
        /**
         * A handle to the implementation of the function or method. In
         * the general case, this handle has signature {@code (O,O[])O},
         * and expects a "self" object and an array of arguments, but in
         * optimised cases it matches.
         */
        // Compare CPython PyMethodDef::ml_meth
        final MethodHandle method;

        /**
         * Construct a method descriptor, identifying the implementation
         * by a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param signature of the method handle
         * @param method handle to invoke the wrapped method or
         *     {@code null} signifying a matching empty handle.
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        Single(PyType objclass, ArgParser argParser,
                MethodSignature signature, MethodHandle method) {
            super(objclass, argParser, signature);
            this.method = signature.prepare(argParser, method);
        }

        /**
         * Construct a Python {@code method} descriptor from an
         * {@link ArgParser} and single {@code MethodHandle} for the
         * implementation. The arguments described by the parser do not
         * include "self".
         *
         * @param objclass owning class
         * @param ap argument parser (provides name etc.)
         * @param mh method handle for the implementation
         * @return a method descriptor supporting the signature
         */
        static Single fromParser(PyType objclass, ArgParser ap,
                MethodHandle mh) {
            // Choose the subclass according to the method signature
            MethodSignature sig = MethodSignature.fromParser(ap);
            switch (sig) {
                case NOARGS:
                    return new NoArgs(objclass, ap, mh);
                case O1:
                    return new O1(objclass, ap, mh);
                case O2:
                    return new O2(objclass, ap, mh);
                case O3:
                    return new O3(objclass, ap, mh);
                case POSITIONAL:
                    return new Positional(objclass, ap, mh);
                default:
                    return new General(objclass, ap, mh);
            }
        }

        @Override
        public MethodHandle getHandle(int selfClassIndex) {
            assert selfClassIndex == 0;
            return method;
        }

        @Override
        MethodHandle getHandle(Object self)
                throws PyBaseException, Throwable {
            // All single class descriptors simply return the handle.
            check(self);
            return method;
        }

        /**
         * The implementation may have any signature supportable in
         * Python by {@link ArgParser}.
         * {@link #fromParser(PyType, ArgParser, List) fromParser()}
         * will choose a {@code General} representation of the method
         * when no optimisations apply. {@code General} overrides the
         * inherited generic call implementation, because we have to use
         * the fully general {@link ArgParser}, and it is able to work
         * on the slice {@code args[1:]} without a copy.
         */
        private static class General extends Single {
            /**
             * Construct a method descriptor, identifying the
             * implementation by a parser and a method handle.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param signature of the method handle
             * @param method handle to invoke the wrapped method or
             *     {@code null} signifying a matching empty handle.
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            General(PyType objclass, ArgParser argParser,
                    MethodHandle method) {
                super(objclass, argParser, MethodSignature.GENERAL,
                        method);
            }

            /**
             * {@inheritDoc}
             * <p>
             * Exceptionally, it pays to override the inherited
             * implementation here because we have to use the fully
             * general {@link ArgParser} and it is able to work on the
             * slice {@code s[p+1:p+n]} without a copy.
             */
            @Override
            public Object vectorcall(Object[] s, int p, int n,
                    String[] names) throws ArgumentError, Throwable {
                int m = n - 1, nk = names == null ? 0 : names.length;
                if (m < nk) {
                    // Not even one argument (self) given by position
                    throw new ArgumentError(Mode.SELF);
                }
                // Call this with self separated.
                Object self = s[p];
                check(self);
                // Parse args without the leading element self
                Object[] frame = argParser.parse(s, p + 1, m, names);
                return method.invokeExact(self, frame);
            }

            /** Equivalent to {@code vectorcall(s, p, n, null)}. */
            @Override
            public Object vectorcall(Object[] s, int p, int n)
                    throws ArgumentError, Throwable {
                return vectorcall(s, p, n, null);
            }

            @Override
            protected Object callMethod(Object self, Object[] args,
                    String[] names) throws PyBaseException, Throwable {
                /*
                 * The method handle type is (O,O[])O. The parser will
                 * make an array of the args, gather excess arguments
                 * into a tuple or dict (where allowed), and fill
                 * missing ones from defaults.
                 */
                check(self);
                assert method
                        .type() == MethodSignature.GENERAL.instanceType;
                Object[] frame = argParser.parse(args, names);
                return method.invokeExact(self, frame);
            }

            @Override
            protected Object callMethod(Object self, Object[] args)
                    throws PyBaseException, Throwable {
                return callMethod(self, args, null);
            }

            @Override
            public Object call(Object[] args, String[] names)
                    throws ArgumentError, Throwable {
                // Call this with self and rest of args separately.
                checkHasSelf(args, names);
                Object self = args[0];
                MethodHandle mh = getHandle(self);
                // Parse args without the leading element self
                Object[] frame = argParser.parse(args, 1,
                        args.length - 1, names);
                return mh.invokeExact(self, frame);
            }
        }

        /**
         * Base class for methods that accept between defined minimum
         * and maximum numbers of arguments {@code self}, that must be
         * given by position. Maximum and minimum may be equal to a
         * single acceptable number.
         * <p>
         * Arguments may not be given by keyword. There is no excess
         * argument (varargs) collector.
         * <p>
         * The number of arguments required by the wrapped Java method
         * sets a maximum allowable number of arguments. Fewer arguments
         * than this may be given, to the extent that defaults specified
         * by the parser make up the difference. The number of available
         * defaults determines the minimum number of arguments to be
         * supplied.
         */
        private static abstract class AbstractPositional
                extends Single {

            /** Default values of the trailing arguments. */
            protected final Object[] d;

            /** Minimum number of positional arguments in a call. */
            protected final int min;

            /** Maximum number of positional arguments in a call. */
            protected final int max;

            /**
             * Construct a method descriptor, identifying the
             * implementation by a parser and a method handle.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param signature to which to coerce the handle
             * @param method handle to invoke the wrapped method or
             *     {@code null} signifying the empty handle.
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            AbstractPositional(PyType objclass, ArgParser argParser,
                    MethodSignature signature, MethodHandle method) {
                super(objclass, argParser, signature, method);
                assert !argParser.hasVarArgs();
                // Cardinal values for positional argument processing
                this.d = argParser.getDefaults();
                this.max = argParser.argcount;
                this.min = argParser.argcount - d.length;
            }

            @Override
            protected Object callMethod(Object self, Object[] args,
                    String[] names) throws PyBaseException, Throwable {
                if (names == null || names.length == 0) {
                    return callMethod(self, args);
                } else {
                    // The self-type error takes precedence if both.
                    check(self);
                    throw new ArgumentError(Mode.NOKWARGS);
                }
            }

            @Override
            public Object call(Object[] args)
                    throws PyBaseException, Throwable {
                int m = args.length - 1;
                if (m < 0) {
                    // Not even one argument
                    throw new ArgumentError(Mode.SELF);
                } else {
                    // Split the leading element self from rest of args
                    Object self = args[0], rest[];
                    if (m == 0) {
                        rest = Util.EMPTY_ARRAY;
                    } else {
                        rest = new Object[m];
                        System.arraycopy(args, 1, rest, 0, m);
                    }

                    // Call this as a method bound to self.
                    return callMethod(self, rest);
                }
            }
        }

        /**
         * A method represented by {@code NoArgs} accepts <b>no</b>
         * arguments after {@code self}, by position or keyword.
         * <p>
         * {@link #fromParser(PyType, ArgParser, List)} will only choose
         * a {@code NoArgs} (or sub-class) representation of the method
         * when this condition applies.
         */
        private static class NoArgs extends AbstractPositional {
            /**
             * Construct a method descriptor, identifying the
             * implementation by a parser and a method handle.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param method handle to invoke the wrapped method or
             *     {@code null} signifying a matching empty handle.
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            NoArgs(PyType objclass, ArgParser argParser,
                    MethodHandle method) {
                super(objclass, argParser, MethodSignature.NOARGS,
                        method);
                assert max == 0;
                assert max - min == d.length;
            }

            @Override
            protected Object callMethod(Object self, Object[] args)
                    throws PyBaseException, Throwable {
                // The method handle type is (O)O
                assert method
                        .type() == MethodSignature.NOARGS.instanceType;
                check(self);
                return method.invokeExact(self);
            }

            @Override
            public Object call(Object self) throws Throwable {
                // The method handle type is (O)O.
                assert method
                        .type() == MethodSignature.NOARGS.instanceType;
                check(self);
                return method.invokeExact(self);
            }
        }

        /**
         * The implementation signature requires {@code self} and one
         * argument, which may be supplied by
         * {@link ArgParser#getDefaults()}.
         */
        private static class O1 extends AbstractPositional {
            /**
             * Construct a method descriptor, identifying the
             * implementation by a parser and a method handle.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param method handle to invoke the wrapped method or
             *     {@code null} signifying a matching empty handle.
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            O1(PyType objclass, ArgParser argParser,
                    MethodHandle method) {
                super(objclass, argParser, MethodSignature.O1, method);
                assert max == 1;
                assert max - min == d.length;
            }

            @Override
            protected Object callMethod(Object self, Object[] a)
                    throws PyBaseException, Throwable {
                // The method handle type is (O,O)O.
                assert method.type() == MethodSignature.O1.instanceType;
                check(self);
                int n = a.length;
                if (n == 1) {
                    // Number of arguments matches number of parameters
                    return method.invokeExact(self, a[0]);
                } else if (n == min) {
                    // min<=max, max==1 and n!=1 therefore n==min==0
                    return method.invokeExact(self, d[0]);
                }
                // n < min || n > max
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self) throws Throwable {
                check(self);
                if (min > 0) { throw new ArgumentError(min, 1); }
                return method.invokeExact(self, d[0]);
            }

            @Override
            public Object call(Object self, Object a1)
                    throws Throwable {
                check(self);
                return method.invokeExact(self, a1);
            }
        }

        /**
         * The implementation signature requires {@code self} and two
         * arguments, which may be supplied by
         * {@link ArgParser#getDefaults()}.
         */
        private static class O2 extends AbstractPositional {

            /**
             * Construct a method descriptor, identifying the
             * implementation by a parser and a method handle.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param method handle to invoke the wrapped method or
             *     {@code null} signifying a matching empty handle.
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            O2(PyType objclass, ArgParser argParser,
                    MethodHandle method) {
                super(objclass, argParser, MethodSignature.O2, method);
                assert max == 2;
                assert max - min == d.length;
            }

            @Override
            protected Object callMethod(Object self, Object[] a)
                    throws ArgumentError, PyBaseException, Throwable {
                // The method handle type is (O,O,O)O.
                assert method.type() == MethodSignature.O2.instanceType;
                check(self);
                int n = a.length, k;
                if (n == 2) {
                    // Number of arguments matches number of parameters
                    return method.invokeExact(self, a[0], a[1]);
                } else if ((k = n - min) >= 0) {
                    if (n == 1) {
                        return method.invokeExact(self, a[0], d[k]);
                    } else if (n == 0)
                        return method.invokeExact(self, d[k++], d[k]);
                }
                // n < min || n > max
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self) throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O2.instanceType;
                if (min == 0) {
                    return mh.invokeExact(self, d[0], d[1]);
                }
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self, Object a1)
                    throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O2.instanceType;
                int k = 1 - min;
                if (k >= 0) { return mh.invokeExact(self, a1, d[k]); }
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self, Object a1, Object a2)
                    throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O2.instanceType;
                return mh.invokeExact(self, a1, a2);
            }
        }

        /**
         * The implementation signature requires {@code self} and three
         * arguments, which may be supplied by
         * {@link ArgParser#getDefaults()}.
         */
        private static class O3 extends AbstractPositional {

            /**
             * Construct a method descriptor, identifying the
             * implementation by a parser and a method handle.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param method handle to invoke the wrapped method or
             *     {@code null} signifying a matching empty handle.
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            O3(PyType objclass, ArgParser argParser,
                    MethodHandle method) {
                super(objclass, argParser, MethodSignature.O3, method);
                assert max == 3;
                assert max - min == d.length;
            }

            @Override
            protected Object callMethod(Object self, Object[] a)
                    throws ArgumentError, PyBaseException, Throwable {
                // The method handle type is (O,O,O,O)O.
                assert method.type() == MethodSignature.O3.instanceType;
                check(self);
                int n = a.length, k;
                if (n == 3) {
                    // Number of arguments matches number of parameters
                    return method.invokeExact(self, a[0], a[1], a[2]);
                } else if ((k = n - min) >= 0) {
                    if (n == 2) {
                        return method.invokeExact(self, a[0], a[1],
                                d[k]);
                    } else if (n == 1) {
                        return method.invokeExact(self, a[0], d[k++],
                                d[k]);
                    } else if (n == 0) {
                        return method.invokeExact(self, d[k++], d[k]);
                    }
                }
                // n < min || n > max
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self) throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O3.instanceType;
                if (min == 0) { return mh.invokeExact(self, d[0]); }
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self, Object a1)
                    throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O3.instanceType;
                int k = 1 - min;
                if (k >= 0) {
                    return mh.invokeExact(self, a1, d[k++], d[k]);
                }
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self, Object a1, Object a2)
                    throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O3.instanceType;
                int k = 2 - min;
                if (k >= 0) {
                    return mh.invokeExact(self, a1, a2, d[k]);
                }
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self, Object a1, Object a2,
                    Object a3) throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O3.instanceType;
                return mh.invokeExact(self, a1, a2, a3);
            }
        }

        /**
         * A method represented by {@code Positional} only accepts
         * arguments after {@code self} given by position. The
         * constraints detailed for {@link AbstractPositional} apply.
         * <p>
         * {@link #fromParser(PyType, ArgParser, List) fromParser()}
         * will only choose a {@code Positional} (or sub-class)
         * representation of the method when these conditions apply.
         */
        private static class Positional extends AbstractPositional {

            /**
             * Construct a method descriptor, identifying the
             * implementation by a parser and a method handle.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param method handle to invoke the wrapped method or
             *     {@code null} signifying the empty handle.
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            Positional(PyType objclass, ArgParser argParser,
                    MethodHandle method) {
                super(objclass, argParser, MethodSignature.POSITIONAL,
                        method);
                assert max == argParser.argcount;
                assert max - min == d.length;
            }

            @Override
            protected Object callMethod(Object self, Object[] a)
                    throws PyBaseException, Throwable {
                // The method handle type is (O,O[])O.
                assert method
                        .type() == MethodSignature.POSITIONAL.instanceType;
                check(self);
                int n = a.length, k;
                if (n == max) {
                    // Number of arguments matches number of parameters
                    return method.invokeExact(self, a);
                } else if ((k = n - min) >= 0) {
                    // Concatenate a[:] and defaults[k:]
                    Object[] frame = new Object[max];
                    System.arraycopy(a, 0, frame, 0, n);
                    System.arraycopy(d, k, frame, n, max - n);
                    return method.invokeExact(self, frame);
                }
                // n < min || n > max
                throw new ArgumentError(min, max);
            }
        }
    }

    /**
     * A {@link PyMethodDescr} for use when the owning Python type has
     * multiple accepted implementations.
     */
    static abstract class Multiple extends PyMethodDescr {
        /**
         * Handles for the particular implementations of a method. The
         * method type of each is {@link PyMethodDescr#signature}.
         */
        protected final MethodHandle[] methods;

        /**
         * Construct a method descriptor, identifying the implementation
         * by a parser and a method handle for each self-class
         * acceptable to {@code objclass} methods.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param signature of the method handles
         * @param candidates handles to the implementations of that
         *     method
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        Multiple(PyType objclass, ArgParser argParser,
                MethodSignature signature,
                List<MethodHandle> candidates) {
            super(objclass, argParser, signature);
            this.methods = prepareCandidates(signature, candidates);
        }

        /**
         * Construct a Python {@code method} descriptor from an
         * {@link ArgParser} and candidate {@code MethodHandle}s for the
         * implementations. The arguments described by the parser do not
         * include "self".
         *
         * @param objclass owning class
         * @param ap argument parser (provides name etc.)
         * @param candidates method handles for the implementations
         * @return a method descriptor supporting the signature
         */
        static Multiple fromParser(PyType objclass, ArgParser ap,
                List<MethodHandle> candidates) {
            // Choose the subclass according to the method signature
            MethodSignature sig = MethodSignature.fromParser(ap);
            switch (sig) {
                case NOARGS:
                    return new NoArgs(objclass, ap, candidates);
                case O1:
                    return new O1(objclass, ap, candidates);
                case O2:
                    return new O2(objclass, ap, candidates);
                case O3:
                    return new O3(objclass, ap, candidates);
                case POSITIONAL:
                    return new Positional(objclass, ap, candidates);
                default:
                    return new General(objclass, ap, candidates);
            }
        }

        @Override
        public MethodHandle getHandle(int selfClassIndex) {
            return methods[selfClassIndex];
        }

        @Override
        MethodHandle getHandle(Object self)
                throws PyBaseException, Throwable {
            /*
             * In multi-class descriptors, we must find the index of a
             * compatible class in objclass.selfClasses(), in order to
             * locate the handle in methods[].
             */
            Class<?> selfClass = self.getClass();
            Representation rep = PyType.registry.get(selfClass);
            PyType selfType = rep.pythonType(self);
            if (selfType == objclass) {
                // selfType defined the method so it must be ok
                return methods[rep.getIndex()];
            } else {
                // Check validity at the Python level
                checkPythonType(selfType);
                // self is an instance of a Python sub-class
                return methods[objclass.getSubclassIndex(selfClass)];
            }
        }

        /**
         * A variant of {@link PyMethodDescr.Multiple} that supports
         * positional and keyword parameters in any allowable pattern.
         */
        private static class General extends Multiple {
            /**
             * Construct a method descriptor, a variant of
             * {@link PyMethodDescr}, that supports
         * positional and keyword parameters in any allowable pattern.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that
             *     method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            General(PyType objclass, ArgParser argParser,
                    List<MethodHandle> candidates) {
                super(objclass, argParser, MethodSignature.GENERAL,
                        candidates);
            }

            @Override
            protected Object callMethod(Object self, Object[] args,
                    String[] names) throws PyBaseException, Throwable {
                /*
                 * The method handle type is (O,O[])O. The parser will
                 * make an array of the args, gather excess arguments
                 * into a tuple or dict (where allowed), and fill
                 * missing ones from defaults.
                 */
                MethodHandle mh = getHandle(self);
                assert mh
                        .type() == MethodSignature.GENERAL.instanceType;
                Object[] frame = argParser.parse(args, names);
                return mh.invokeExact(self, frame);
            }

            @Override
            protected Object callMethod(Object self, Object[] args)
                    throws PyBaseException, Throwable {
                return callMethod(self, args, null);
            }

            /**
             * {@inheritDoc}
             * <p>
             * Exceptionally, it pays to override the inherited
             * implementation here because we have to use the fully
             * general {@link ArgParser} and it is able to work on the
             * slice {@code args[1:]} without a copy.
             */
            @Override
            public Object call(Object[] args, String[] names)
                    throws ArgumentError, Throwable {
                // Call this with self and rest of args separately.
                checkHasSelf(args, names);
                Object self = args[0];
                MethodHandle mh = getHandle(self);
                // Parse args without the leading element self
                Object[] frame = argParser.parse(args, 1,
                        args.length - 1, names);
                return mh.invokeExact(self, frame);
            }

            /**
             * {@inheritDoc}
             * <p>
             * Exceptionally, it pays to override the inherited
             * implementation here because we have to use the fully
             * general {@link ArgParser} and it is able to work on the
             * slice {@code s[p+1:p+n]} without a copy.
             */
            @Override
            public Object vectorcall(Object[] s, int p, int n,
                    String[] names) throws ArgumentError, Throwable {
                int m = n - 1, nk = names == null ? 0 : names.length;
                if (m < nk) {
                    // Not even one argument (self) given by position
                    throw new ArgumentError(Mode.SELF);
                }
                // Call this with self separated.
                Object self = s[p];
                MethodHandle mh = getHandle(self);
                // Parse args without the leading element self
                Object[] frame = argParser.parse(s, p + 1, m, names);
                return mh.invokeExact(self, frame);
            }

            /** Equivalent to {@code vectorcall(s, p, n, null)}. */
            @Override
            public Object vectorcall(Object[] s, int p, int n)
                    throws ArgumentError, Throwable {
                return vectorcall(s, p, n, null);
            }
        }

        /**
         * A variant of {@link PyMethodDescr.Multiple} that
accepts between defined minimum
         * and maximum numbers of arguments after {@code self}, that must be
         * given by position. Maximum and minimum may be equal to a
         * single acceptable number.
         * <p>
         * Arguments may not be given by keyword. There is no excess
         * argument (varargs) collector.
         * <p>
         * The number of arguments required by the wrapped Java method
         * sets a maximum allowable number of arguments. Fewer arguments
         * than this may be given, to the extent that defaults specified
         * by the parser make up the difference. The number of available
         * defaults determines the minimum number of arguments to be
         * supplied.
         */
        private static abstract class AbstractPositional
                extends Multiple {

            /** Default values of the trailing arguments. */
            protected final Object[] d;

            /** Minimum number of positional arguments in a call. */
            protected final int min;

            /** Maximum number of positional arguments in a call. */
            protected final int max;

            /**
             * Construct a method descriptor, identifying the
             * implementation by a parser and a method handle.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param signature to which to coerce the handle
             *
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            AbstractPositional(PyType objclass, ArgParser argParser,
                    MethodSignature signature,
                    List<MethodHandle> candidates) {
                super(objclass, argParser, signature, candidates);
                assert !argParser.hasVarArgs();
                // Cardinal values for positional argument processing
                this.d = argParser.getDefaults();
                this.max = argParser.argcount;
                this.min = argParser.argcount - d.length;
            }

            @Override
            protected Object callMethod(Object self, Object[] args,
                    String[] names) throws PyBaseException, Throwable {
                if (names == null || names.length == 0) {
                    return callMethod(self, args);
                } else {
                    // The self-type error takes precedence if both.
                    check(self);
                    throw new ArgumentError(Mode.NOKWARGS);
                }
            }

            @Override
            public Object call(Object[] args)
                    throws PyBaseException, Throwable {
                int m = args.length - 1;
                if (m < 0) {
                    // Not even one argument
                    throw new ArgumentError(Mode.SELF);
                } else {
                    // Split the leading element self from rest of args
                    Object self = args[0], rest[];
                    if (m == 0) {
                        rest = Util.EMPTY_ARRAY;
                    } else {
                        rest = new Object[m];
                        System.arraycopy(args, 1, rest, 0, m);
                    }

                    // Call this as a method bound to self.
                    return callMethod(self, rest);
                }
            }
        }

        /**
         * A variant of {@link AbstractPositional} that supports
         * no arguments after {@code self}
         * and multiple accepted implementations of {@code objclass}.
         */
        static class NoArgs extends AbstractPositional {
            /**
             * Construct a method descriptor that supports
         * no arguments after {@code self}
         * and multiple accepted implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that
             *     method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            NoArgs(PyType objclass, ArgParser argParser,
                    List<MethodHandle> candidates) {
                super(objclass, argParser, MethodSignature.NOARGS,
                        candidates);
            }

            @Override
            protected Object callMethod(Object self, Object[] args)
                    throws PyBaseException, Throwable {
                // The method handle type is (O)O (no args after self).
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.NOARGS.instanceType;
                return mh.invokeExact(self);
            }

            @Override
            public Object call(Object self) throws Throwable {
                // The method handle type is (O)O.
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.NOARGS.instanceType;
                return mh.invokeExact(self);
            }
        }

        /**
         * A variant of {@link AbstractPositional} that supports
         * at most one argument after {@code self}
         * and multiple accepted implementations of {@code objclass}.
         */
        static class O1 extends AbstractPositional {
            /**
             * Construct a method descriptor, that supports
         * at most one argument after {@code self}
         * and multiple accepted implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that
             *     method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            O1(PyType objclass, ArgParser argParser,
                    List<MethodHandle> candidates) {
                super(objclass, argParser, MethodSignature.O1,
                        candidates);
            }

            @Override
            protected Object callMethod(Object self, Object[] a)
                    throws PyBaseException, Throwable {
                // The method handle type is (O,O)O.
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O1.instanceType;
                int n = a.length;
                if (n == 1) {
                    // Number of arguments matches number of parameters
                    return mh.invokeExact(self, a[0]);
                } else if (n == min) {
                    // min<=max, max==1 and n!=1 therefore n==min==0
                    return mh.invokeExact(self, d[0]);
                }
                // n < min || n > max
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self) throws Throwable {
                MethodHandle mh = getHandle(self);
                if (min > 0) { throw new ArgumentError(min, 1); }
                return mh.invokeExact(self, d[0]);
            }

            @Override
            public Object call(Object self, Object a1)
                    throws Throwable {
                MethodHandle mh = getHandle(self);
                return mh.invokeExact(self, a1);
            }
        }

        /**
         * A variant of {@link AbstractPositional} that supports
         * at most two arguments after {@code self}
         * and multiple accepted implementations of {@code objclass}.
         */
        static class O2 extends AbstractPositional {
            /**
             * Construct a method descriptor that supports
         * at most two arguments after {@code self}
         * and multiple accepted implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that
             *     method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            O2(PyType objclass, ArgParser argParser,
                    List<MethodHandle> candidates) {
                super(objclass, argParser, MethodSignature.O2,
                        candidates);
            }

            @Override
            protected Object callMethod(Object self, Object[] a)
                    throws ArgumentError, PyBaseException, Throwable {
                // The method handle type is (O,O,O)O.
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O2.instanceType;
                int n = a.length, k;
                if (n == 2) {
                    // Number of arguments matches number of parameters
                    return mh.invokeExact(self, a[0], a[1]);
                } else if ((k = n - min) >= 0) {
                    if (n == 1) {
                        return mh.invokeExact(self, a[0], d[k]);
                    } else if (n == 0)
                        return mh.invokeExact(self, d[k++], d[k]);
                }
                // n < min || n > max
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self) throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O2.instanceType;
                if (min == 0) {
                    return mh.invokeExact(self, d[0], d[1]);
                }
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self, Object a1)
                    throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O2.instanceType;
                int k = 1 - min;
                if (k >= 0) { return mh.invokeExact(self, a1, d[k]); }
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self, Object a1, Object a2)
                    throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O2.instanceType;
                return mh.invokeExact(self, a1, a2);
            }
        }

        /**
         * A variant of {@link PyMethodDescr} that supports
         * at most three arguments after {@code self}
         * and multiple accepted implementations of {@code objclass}.
         */
        static class O3 extends AbstractPositional {
            /**
             * Construct a method descriptor that supports
         * at most three arguments after {@code self}
         * and multiple accepted implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that
             *     method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            O3(PyType objclass, ArgParser argParser,
                    List<MethodHandle> candidates) {
                super(objclass, argParser, MethodSignature.O3,
                        candidates);
            }

            @Override
            protected Object callMethod(Object self, Object[] a)
                    throws ArgumentError, PyBaseException, Throwable {
                // The method handle type is (O,O,O,O)O.
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O3.instanceType;
                int n = a.length, k;
                if (n == 3) {
                    // Number of arguments matches number of parameters
                    return mh.invokeExact(self, a[0], a[1], a[2]);
                } else if ((k = n - min) >= 0) {
                    if (n == 2) {
                        return mh.invokeExact(self, a[0], a[1], d[k]);
                    } else if (n == 1) {
                        return mh.invokeExact(self, a[0], d[k++], d[k]);
                    } else if (n == 0) {
                        return mh.invokeExact(self, d[k++], d[k]);
                    }
                }
                // n < min || n > max
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self) throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O3.instanceType;
                if (min == 0) { return mh.invokeExact(self, d[0]); }
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self, Object a1)
                    throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O3.instanceType;
                int k = 1 - min;
                if (k >= 0) {
                    return mh.invokeExact(self, a1, d[k++], d[k]);
                }
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self, Object a1, Object a2)
                    throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O3.instanceType;
                int k = 2 - min;
                if (k >= 0) {
                    return mh.invokeExact(self, a1, a2, d[k]);
                }
                throw new ArgumentError(min, max);
            }

            @Override
            public Object call(Object self, Object a1, Object a2,
                    Object a3) throws Throwable {
                MethodHandle mh = getHandle(self);
                assert mh.type() == MethodSignature.O3.instanceType;
                return mh.invokeExact(self, a1, a2, a3);
            }
        }

        /**
         * A variant of {@link PyMethodDescr} that supports
         * a minimum and maximum number of positional
         *  arguments after {@code self}
         * and multiple accepted implementations of {@code objclass}.
         */
        static class Positional extends AbstractPositional {
            /**
             * Construct a method descriptor that supports
         * a minimum and maximum number of positional
         *  arguments after {@code self}
         * and multiple accepted implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that
             *     method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            Positional(PyType objclass, ArgParser argParser,
                    List<MethodHandle> candidates) {
                super(objclass, argParser, MethodSignature.POSITIONAL,
                        candidates);
            }

            @Override
            protected Object callMethod(Object self, Object[] a)
                    throws PyBaseException, Throwable {
                // The method handle type is (O,O[])O.
                MethodHandle mh = getHandle(self);
                assert mh
                        .type() == MethodSignature.POSITIONAL.instanceType;
                int n = a.length, k;
                if (n == max) {
                    // Number of arguments matches number of parameters
                    return mh.invokeExact(self, a);
                } else if ((k = n - min) >= 0) {
                    // Concatenate a[:] and defaults[k:]
                    Object[] frame = new Object[max];
                    System.arraycopy(a, 0, frame, 0, n);
                    System.arraycopy(d, k, frame, n, max - n);
                    return mh.invokeExact(self, frame);
                }
                // n < min || n > max
                throw new ArgumentError(min, max);
            }
        }
    }
}
